<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>{{ title }} - Myflix</title>
    <link rel="stylesheet" href="/css/player.css">
    <link rel="stylesheet" href="/css/watch-mark.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="player-container">
        <div class="video-wrapper">
            <!-- Loading Indicator -->
            <div class="loading-indicator" id="loadingIndicator">
                <div class="loader"></div>
                <p>Loading video...</p>
                <p class="loading-source" id="loadingSource">Trying source 1...</p>
            </div>
            
            <!-- Error Message -->
            <div class="error-message" id="errorMessage" style="display: none;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z" fill="currentColor"/>
                </svg>
                <h2>Video not available</h2>
                <p>The video source is currently unavailable. Please try a different source.</p>
                <button class="retry-button" onclick="showSourceMenu()">Try Different Source</button>
            </div>
            
        <iframe id="videoIframe"
            src="about:blank" 
                    width="100%" 
                    height="100%" 
                    frameborder="0" 
                    allowfullscreen
                    webkitallowfullscreen
                    mozallowfullscreen
                    allow="autoplay; fullscreen; encrypted-media; picture-in-picture"
                    referrerpolicy="origin"
                    onload="hideLoading()"
                    onerror="showError()"></iframe>
            
            <div class="player-controls" id="topControls">
                <div class="top-bar">
                    <a href="javascript:history.back()" class="back-button">
                        ‚Üê Back
                    </a>
                    
                    <div class="episode-info">
                        <h2 class="episode-title">{{ title }}</h2>
                        <p class="series-info">{{ type|title }}</p>
                    </div>
                    
                    <!-- Source Switcher Button -->
                    <button class="source-switcher-btn" id="sourceSwitch" onclick="showSourceMenu()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="currentColor"/>
                        </svg>
                        Change Source
                    </button>
                </div>
            </div>
            
            <!-- Source Selector Menu -->
            <div class="source-menu" id="sourceMenu" style="display: none;">
                <div class="source-menu-header">
                    <h3>Select Video Source</h3>
                    <button class="close-menu-btn" onclick="hideSourceMenu()">‚úï</button>
                </div>
                <p class="source-info-top">If the video doesn't play, try switching to a different source. Each source may have different availability.</p>
                <div class="source-list">
                    {% if embed_sources %}
                        {% for source in embed_sources %}
                        <button class="source-option {% if loop.index == 1 %}active{% endif %}" 
                                data-source="{{ source }}" 
                                onclick="switchSource('{{ source }}', this)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                            </svg>
                            <span class="source-info-text">
                                <span class="source-name">Source {{ loop.index }}</span>
                                <span class="source-domain">{{ source.split('/')[2] }}</span>
                            </span>
                            <span class="source-status" id="status-{{ loop.index }}">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="10" fill="currentColor"/>
                                </svg>
                            </span>
                        </button>
                        {% endfor %}
                    {% endif %}
                </div>
                <div class="troubleshooting-tips">
                    <p class="tip-title">üí° Troubleshooting Tips:</p>
                    <ul>
                        <li>Wait a few seconds for the video to buffer</li>
                        <li>Try a different source if one doesn't work</li>
                        <li>Check your internet connection</li>
                        <li>Disable ad-blockers if video won't load</li>
                        <li>Try refreshing the page</li>
                    </ul>
                </div>
                <div class="direct-links">
                    <p class="tip-title">üîó Still not working? Try these direct links:</p>
                    <div class="direct-link-buttons">
                        {% if tmdb_id %}
                        <a href="https://vidsrc.to/embed/{{ 'movie' if type == 'movie' else 'tv' }}/{{ tmdb_id }}{% if season %}/{{ season }}/{{ episode }}{% endif %}" 
                           target="_blank" 
                           class="direct-link-btn">
                            Open VidSrc.to
                        </a>
                        <a href="https://www.2embed.cc/{% if type == 'movie' %}embed{% else %}embedtv{% endif %}/{{ imdb_id }}{% if season %}&s={{ season }}&e={{ episode }}{% endif %}" 
                           target="_blank" 
                           class="direct-link-btn">
                            Open 2Embed
                        </a>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Skip Intro Button -->
            <button class="skip-intro-button" id="skipIntroBtn" style="display: none;" onclick="skipIntro()">
                Skip Intro
            </button>

            <!-- Next Episode Button (always visible when available) -->
            <button class="next-episode-quick-btn" id="nextEpisodeQuickBtn" style="display: none;" onclick="playNextEpisode()" title="Next Episode (N)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M7 18h2V6H7v12zm4-12v12l9-6-9-6z" fill="currentColor"/>
                </svg>
                Next
            </button>

            <!-- Skip Credits/Next Episode -->
            <div class="next-episode-container" id="nextEpisodeContainer" style="display: none;">
                <div class="next-episode-info">
                    <div class="next-episode-thumbnail">
                        <div class="play-icon-overlay">‚ñ∂</div>
                    </div>
                    <div class="next-episode-text">
                        <p class="next-episode-label">Next Episode</p>
                        <h3 class="next-episode-title">Continue Watching</h3>
                    </div>
                </div>
                <button class="watch-next-button" onclick="playNextEpisode()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8 5v14l11-7z" fill="currentColor"/>
                    </svg>
                    Play
                </button>
            </div>

            <!-- Auto-play countdown -->
            <div class="autoplay-countdown" id="autoplayCountdown" style="display: none;">
                <div class="countdown-content">
                    <p>Next episode playing in <span id="countdownTimer">5</span> seconds</p>
                    <button class="cancel-autoplay" onclick="cancelAutoplay()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let controlsVisible = true;
        let controlsTimeout;
        let playbackStartTime = Date.now();
        let currentProgress = 0;
        let videoDuration = 0;
        let introStart = 30; // Intro starts at 30 seconds
        let introEnd = 90;   // Intro ends at 90 seconds
        let creditsStart = 0; // Will be set based on video duration
        let hasSkippedIntro = false;
        let autoplayTimer = null;
        let countdownInterval = null;
        
        const videoType = "{{ type }}";
        // Parse the tmdb/imdb id from the original embed_url if present
        const videoId = ("{{ embed_url }}" || "").match(/(?:tmdb=|\/)(tt\d+|\d+)/)?.[1] || '';
        const videoTitle = "{{ title }}";
        const imdbId = "{{ imdb_id }}";
        const tmdbId = "{{ tmdb_id }}";
        const season = {% if season is defined %}{{ season }}{% else %}null{% endif %};
        const episode = {% if episode is defined %}{{ episode }}{% else %}null{% endif %};
        const currentSeason = {% if season %}{{ season }}{% else %}null{% endif %};
        const currentEpisode = {% if episode %}{{ episode }}{% else %}null{% endif %};
        const seriesTitle = "{{ series_title if series_title else title }}";
        let currentSourceIndex = 0;
        let nextEpisodeData = null;
        // List of embed sources rendered from server
        const embedSources = [
            {% if embed_sources %}
                {% for s in embed_sources %}
                    "{{ s }}"{{ "," if not loop.last }}
                {% endfor %}
            {% endif %}
        ];
        
        // Show/hide controls on mouse movement
        document.addEventListener('mousemove', showControls);
        document.addEventListener('click', showControls);
        
        function showControls() {
            const controls = document.getElementById('topControls');
            controls.style.opacity = '1';
            controlsVisible = true;
            
            clearTimeout(controlsTimeout);
            controlsTimeout = setTimeout(() => {
                controls.style.opacity = '0';
                controlsVisible = false;
            }, 3000);
        }
        
        // Hide controls when not moving mouse
        document.addEventListener('mouseleave', function() {
            const controls = document.getElementById('topControls');
            controls.style.opacity = '0';
            controlsVisible = false;
        });
        
        // Show controls initially
        showControls();
        
        // Simulate video progress tracking (since iframe blocks direct access)
        function startProgressTracking() {
            setInterval(() => {
                currentProgress = (Date.now() - playbackStartTime) / 1000; // seconds
                
                // Show skip intro button
                if (currentProgress >= introStart && currentProgress <= introEnd && !hasSkippedIntro) {
                    document.getElementById('skipIntroBtn').style.display = 'block';
                } else {
                    document.getElementById('skipIntroBtn').style.display = 'none';
                }
                
                // Show next episode container near end (only if next episode is available)
                if (videoType === 'episode' && nextEpisodeData && nextEpisodeData.has_next && videoDuration > 0 && currentProgress >= (videoDuration - 120)) {
                    document.getElementById('nextEpisodeContainer').style.display = 'flex';
                }
                
                // Start autoplay countdown (only if next episode is available)
                if (videoType === 'episode' && nextEpisodeData && nextEpisodeData.has_next && videoDuration > 0 && currentProgress >= (videoDuration - 30)) {
                    startAutoplayCountdown();
                }
                
                // Save progress every 10 seconds
                if (Math.floor(currentProgress) % 10 === 0) {
                    saveProgress();
                }
            }, 1000);
        }
        
        function skipIntro() {
            hasSkippedIntro = true;
            document.getElementById('skipIntroBtn').style.display = 'none';
            // In a real implementation, this would seek the video
            playbackStartTime = Date.now() - (introEnd * 1000);
            showToast('Skipped intro');
        }
        
        function playNextEpisode() {
            showToast('Loading next episode...');
            // In a real implementation, navigate to next episode
            setTimeout(() => {
                window.location.href = '/'; // Placeholder - would navigate to next episode
            }, 1000);
        }
        
        function startAutoplayCountdown() {
            if (autoplayTimer || !nextEpisodeData || !nextEpisodeData.has_next) return; // Already started or no next episode
            
            let countdown = 5;
            document.getElementById('autoplayCountdown').style.display = 'block';
            document.getElementById('countdownTimer').textContent = countdown;
            
            countdownInterval = setInterval(() => {
                countdown--;
                document.getElementById('countdownTimer').textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    playNextEpisode();
                }
            }, 1000);
            
            autoplayTimer = true;
        }
        
        function cancelAutoplay() {
            clearInterval(countdownInterval);
            document.getElementById('autoplayCountdown').style.display = 'none';
            autoplayTimer = null;
        }
        
        function saveProgress() {
            const progressData = {
                type: videoType === 'episode' ? 'series' : videoType,
                id: imdbId,
                imdb_id: imdbId,
                tmdb_id: tmdbId,
                title: videoTitle,
                progress: Math.floor(currentProgress),
                duration: Math.floor(videoDuration || 3600)
            };
            
            // Add episode info for series
            if (videoType === 'episode' && typeof season !== 'undefined' && typeof episode !== 'undefined') {
                progressData.season = season;
                progressData.episode = episode;
            }
            
            fetch('/api/watch_progress', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(progressData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Progress saved:', data.progress_percent + '%');
                    if (data.is_completed) {
                        console.log('Marked as completed!');
                    }
                }
            })
            .catch(err => console.log('Failed to save progress:', err));
        }
        
        // Load saved progress on page load
        function loadSavedProgress() {
            let url = `/api/watch_progress/${videoType === 'episode' ? 'series' : videoType}/${videoId}`;
            
            // Add episode params for series
            if (videoType === 'episode' && typeof season !== 'undefined' && typeof episode !== 'undefined') {
                url += `?season=${season}&episode=${episode}`;
            }
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.progress && data.progress.progress_seconds > 0) {
                        const savedProgress = data.progress;
                        const progressPercent = savedProgress.progress_percent;
                        
                        // Only resume if not completed and progress is significant (>5% but <90%)
                        if (!savedProgress.is_completed && progressPercent > 5 && progressPercent < 90) {
                            const minutes = Math.floor(savedProgress.progress_seconds / 60);
                            const seconds = savedProgress.progress_seconds % 60;
                            const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                            
                            showResumePrompt(savedProgress.progress_seconds, timeStr, progressPercent);
                        }
                    }
                })
                .catch(err => console.log('Failed to load progress:', err));
        }
        
        function showResumePrompt(progressSeconds, timeStr, progressPercent) {
            const prompt = document.createElement('div');
            prompt.className = 'resume-prompt';
            prompt.innerHTML = `
                <div class="resume-content">
                    <p>Resume from ${timeStr}? (${progressPercent.toFixed(0)}% watched)</p>
                    <div class="resume-buttons">
                        <button onclick="resumePlayback(${progressSeconds})" class="btn-resume">Resume</button>
                        <button onclick="dismissResumePrompt()" class="btn-start-over">Start Over</button>
                    </div>
                </div>
            `;
            document.body.appendChild(prompt);
            
            setTimeout(() => prompt.classList.add('show'), 100);
        }
        
        window.resumePlayback = function(seconds) {
            // Try to set the iframe's video position
            // This works with some embed players that support URL parameters
            const iframe = document.querySelector('iframe');
            if (iframe && iframe.src) {
                const url = new URL(iframe.src);
                url.searchParams.set('t', seconds);
                iframe.src = url.toString();
            }
            dismissResumePrompt();
            showToast('Resuming playback...');
        };
        
        window.dismissResumePrompt = function() {
            const prompt = document.querySelector('.resume-prompt');
            if (prompt) {
                prompt.classList.remove('show');
                setTimeout(() => prompt.remove(), 300);
            }
        };
        
        // Load progress when page loads
        window.addEventListener('load', loadSavedProgress);
        
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }
        
        // Mark as watched function
        window.markAsWatched = function() {
            const data = {
                type: videoType === 'episode' ? 'series' : videoType,
                id: videoId
            };
            
            if (videoType === 'episode' && typeof season !== 'undefined' && typeof episode !== 'undefined') {
                data.season = season;
                data.episode = episode;
            }
            
            fetch('/api/mark_watched', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Marked as watched ‚úì');
                }
            })
            .catch(err => console.log('Failed to mark as watched:', err));
        };
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'f' || e.key === 'F') {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            }
            if (e.key === 'Escape') {
                showControls();
            }
            if (e.key === 'n' || e.key === 'N') {
                // Next episode shortcut
                if (nextEpisodeData && nextEpisodeData.has_next) {
                    playNextEpisode();
                }
            }
            if (e.key === 's' || e.key === 'S') {
                // Skip intro shortcut
                if (currentProgress >= introStart && currentProgress <= introEnd && !hasSkippedIntro) {
                    skipIntro();
                }
            }
        });
        
        // Load next episode information for series episodes
        async function loadNextEpisodeInfo() {
            if (videoType === 'episode' && currentSeason && currentEpisode) {
                try {
                    const response = await fetch(`/api/next_episode/${imdbId}/${currentSeason}/${currentEpisode}`);
                    const data = await response.json();
                    
                    if (data.has_next) {
                        nextEpisodeData = data;
                        
                        // Update next episode info in the UI
                        const nextEpisodeTitle = document.querySelector('.next-episode-title');
                        const nextEpisodeLabel = document.querySelector('.next-episode-label');
                        const nextEpisodeThumbnail = document.querySelector('.next-episode-thumbnail');
                        const quickNextBtn = document.getElementById('nextEpisodeQuickBtn');
                        
                        if (nextEpisodeTitle) {
                            nextEpisodeTitle.textContent = data.next_title;
                        }
                        if (nextEpisodeLabel) {
                            nextEpisodeLabel.textContent = `S${data.next_season}E${data.next_episode}`;
                        }
                        if (nextEpisodeThumbnail && data.next_still_path) {
                            nextEpisodeThumbnail.style.backgroundImage = `url(${data.next_still_path})`;
                            nextEpisodeThumbnail.style.backgroundSize = 'cover';
                            nextEpisodeThumbnail.style.backgroundPosition = 'center';
                        }
                        
                        // Show the quick next episode button
                        if (quickNextBtn) {
                            quickNextBtn.style.display = 'flex';
                            quickNextBtn.title = `Next: S${data.next_season}E${data.next_episode} - ${data.next_title}`;
                        }
                    }
                } catch (error) {
                    console.log('Failed to load next episode info:', error);
                }
            }
        }

        // Enhanced play next episode function
        function playNextEpisode() {
            if (nextEpisodeData && nextEpisodeData.has_next) {
                showToast('Loading next episode...');
                const nextUrl = `/watch/series/${imdbId}/${nextEpisodeData.next_season}/${nextEpisodeData.next_episode}`;
                setTimeout(() => {
                    window.location.href = nextUrl;
                }, 1000);
            } else {
                showToast('No next episode available');
            }
        }

        // Start tracking when page loads
        window.addEventListener('load', () => {
            // Estimate video duration (for movies ~7200s, series ~2700s)
            videoDuration = videoType === 'movie' ? 7200 : 2700;
            creditsStart = videoDuration - 180; // Credits start 3 minutes before end
            
            startProgressTracking();
            
            // Load next episode info for series
            loadNextEpisodeInfo();
            
            // Save initial view
            setTimeout(() => saveProgress(), 5000);
            
            // Probe embed sources and set the iframe to the first one that allows framing
            selectWorkingSource(embedSources).then(chosen => {
                if (chosen) {
                    const iframe = document.getElementById('videoIframe');
                    iframe.src = chosen;
                } else {
                    // No working source found ‚Äî show error message
                    showError();
                }
            }).catch(err => {
                console.error('Error selecting embed source', err);
                showError();
            });

            // Auto-hide loading after 10 seconds if iframe hasn't signaled load
            setTimeout(() => {
                hideLoading();
            }, 10000);
        });

        // Try each source sequentially by asking the server whether the URL allows framing.
        // Returns a promise that resolves to the first URL that allows framing or null.
        async function selectWorkingSource(sources) {
            if (!sources || !sources.length) return null;
            for (let i = 0; i < sources.length; i++) {
                const src = sources[i];
                try {
                    showLoading(i + 1);
                    const resp = await fetch('/embed_check', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ url: src })
                    });
                    const json = await resp.json();
                    if (json.allows) {
                        currentSourceIndex = i;
                        hideSourceMenu();
                        return src;
                    }
                } catch (e) {
                    console.warn('Embed check failed for', src, e);
                }
            }
            return null;
        }
        
        // Functions for handling video loading states
        function hideLoading() {
            const loader = document.getElementById('loadingIndicator');
            if (loader) {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 300);
            }
        }
        
        function showError() {
            const loader = document.getElementById('loadingIndicator');
            const error = document.getElementById('errorMessage');
            if (loader) loader.style.display = 'none';
            if (error) error.style.display = 'flex';
        }
        
        function hideError() {
            const error = document.getElementById('errorMessage');
            if (error) error.style.display = 'none';
        }
        
        function showLoading(sourceNum) {
            const loader = document.getElementById('loadingIndicator');
            const loadingSource = document.getElementById('loadingSource');
            hideError();
            if (loader) {
                loader.style.display = 'flex';
                loader.style.opacity = '1';
            }
            if (loadingSource) {
                loadingSource.textContent = `Trying source ${sourceNum}...`;
            }
        }
        
        // Save progress before leaving
        window.addEventListener('beforeunload', saveProgress);
        
        // Source switching functionality
        function showSourceMenu() {
            const menu = document.getElementById('sourceMenu');
            menu.style.display = 'flex';
            setTimeout(() => menu.classList.add('show'), 10);
        }
        
        function hideSourceMenu() {
            const menu = document.getElementById('sourceMenu');
            menu.classList.remove('show');
            setTimeout(() => menu.style.display = 'none', 300);
        }
        
        function switchSource(sourceUrl, button) {
            // Update active button
            document.querySelectorAll('.source-option').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Get source number
            const sourceNum = button.textContent.match(/\d+/)[0];
            showLoading(sourceNum);
            
            // Switch iframe source
            const iframe = document.getElementById('videoIframe');
            iframe.src = sourceUrl;
            
            // Show notification
            showToast('Switching video source...');
            
            // Hide menu after short delay
            setTimeout(hideSourceMenu, 500);
            
            // Auto-hide loading after timeout
            setTimeout(() => hideLoading(), 8000);
        }
    </script>
</body>
</html>
